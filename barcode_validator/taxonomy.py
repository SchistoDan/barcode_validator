import logging
import tempfile
import subprocess
import threading
import io
import os
import tarfile
from Bio import SeqIO
from barcode_validator.config import Config
from nbt.Phylo.BOLDXLSXIO import Parser as BOLDParser
from nbt.Phylo.NCBITaxdmp import Parser as NCBIParser


def read_bold_taxonomy(spreadsheet):
    """
    Read a BOLD taxonomy spreadsheet. This is a file that is generated by the BOLD workbench and contains taxonomic
    information for a set of sequences. The file must contain two tabs: 'Lab Sheet' and 'Taxonomy'. The 'Lab Sheet' tab
    must contain two columns: 'Sample ID' and 'Process ID'. The 'Taxonomy' tab must contain columns for the taxonomic
    ranks (Phylum, Class, Order, Family, Subfamily, Tribe, Genus, Species, Subspecies). The parser will create a tree
    with the taxonomic ranks as nodes and the sample IDs as leaves. The tree will be returned as a BaseTree object but
    its nodes will be Taxon objects. The terminal Taxon nodes will have a 'processid' field in the guid attribute that
    maps to the 'Process ID' column in the 'Lab Sheet' tab.
    :param spreadsheet: A path to the BOLD taxonomy spreadsheet
    :return: A BaseTree object with Taxon nodes
    """
    # Read the Excel file into a BytesIO object
    with open(spreadsheet, 'rb') as file:
        excel_data = io.BytesIO(file.read())

    # Pass the BytesIO object to BOLDParser
    return BOLDParser(excel_data).parse()


def read_ncbi_taxonomy(taxdump):
    """
    Read the NCBI taxonomy from a taxdump file. This is a tarball that contains two files: nodes.dmp and names.dmp.
    The nodes.dmp file contains the taxonomic tree structure, while the names.dmp file contains the taxon names.
    The nodes will have a 'taxon' field in the guid attribute that maps to the NCBI taxon ID.
    :param taxdump: A path to the taxdump tarball
    :return: A BaseTree object with Taxon nodes
    """
    logging.info("Reading NCBI taxonomy")
    tar = tarfile.open(taxdump, "r:gz")
    return NCBIParser(tar).parse()


def _log_output(stream, log_level):
    """
    Log the output of a subprocess to the logger at the specified level.
    :param stream: A stream object
    :param log_level: A logging level
    :return:
    """
    for msg in stream:
        msg = msg.strip()
        if msg:
            logging.log(log_level, f"BLASTN output: {msg}")


def run_localblast(sequence, tree):
    """
    Run a local BLASTN search against a local database and return the taxonomic lineages of the hits.
    :param sequence: A Bio.SeqRecord object
    :param tree: A Bio.Phylo.BaseTree object created by NCBIParser()
    :return: A list of distinct higher taxa at the specified rank
    """
    logging.info("Running local BLASTN...")

    # Create a temporary file for the input sequence
    with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.fasta') as temp_input:
        SeqIO.write(sequence, temp_input, "fasta")
        temp_input_name = temp_input.name
    blast_result = f"{temp_input_name}.tsv"  # output file name, as blast TSV (see -outfmt option)

    # Run local BLASTN
    config = Config()
    os.environ['BLASTDB_LMDB_MAP_SIZE'] = str(config.get('BLASTDB_LMDB_MAP_SIZE'))
    try:
        outfmt = "6 qseqid sseqid pident length qstart qend sstart send evalue bitscore staxids"
        process = subprocess.Popen(['blastn',
                                    '-db', str(config.get('blast_db')),
                                    '-num_threads', str(config.get('num_threads')),
                                    '-evalue', str(config.get('evalue')),
                                    '-max_target_seqs', str(config.get('max_target_seqs')),
                                    '-word_size', str(config.get('word_size')),
                                    '-query', temp_input_name,
                                    '-task', 'megablast',
                                    '-outfmt', outfmt,
                                    '-out', blast_result
                                    ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        # Start threads to handle stdout and stderr and wait for the process to complete
        threading.Thread(target=_log_output, args=(process.stdout, logging.INFO)).start()
        threading.Thread(target=_log_output, args=(process.stderr, logging.ERROR)).start()
        return_code = process.wait()
        if return_code != 0:
            raise subprocess.CalledProcessError(return_code, 'blastn')
        return parse_blast_result(blast_result, tree)

    # Handle exception
    except subprocess.CalledProcessError as e:
        logging.error(f"Error running local BLASTN: {e}")
        raise


def parse_blast_result(blast_result, tree):
    """
    Parse the BLAST result file and return the distinct higher taxa that sit at the configured taxonomic level.
    :param blast_result: A path to the BLAST result file
    :param tree: A Bio.Phylo.BaseTree object created by NCBIParser()
    :return: A list of distinct higher taxa at the specified rank
    """
    # Parse BLAST result
    distinct_taxids = set()
    with open(blast_result, 'r') as file:
        for line in file:
            columns = line.strip().split('\t')
            if columns:
                taxid_field = columns[-1]
                taxids = taxid_field.split(';')
                distinct_taxids.update(taxid.strip() for taxid in taxids if taxid.strip())
    logging.info(f'{len(distinct_taxids)} distinct taxids found in BLAST result')
    logging.debug(distinct_taxids)
    return collect_higher_taxa(distinct_taxids, tree)


def collect_higher_taxa(taxids, tree):
    """
    Collect the distinct higher taxa that sit at the configured taxonomic level for an input set of NCBI taxids. For
    example, if the taxonomic level is 'family', the function will return a list of distinct families that are
    encountered in the traversal of the tree from the tips with the specified taxids to the root.
    :param taxids: A set of NCBI taxids
    :param tree: A Bio.Phylo.BaseTree object created by NCBIParser()
    :return: A list of distinct higher taxa at the specified rank
    """
    tips = []
    config = Config()

    # Iterate over all tips in the NCBI taxonomy tree
    # to collect all tips with the specified taxids
    for tip in tree.get_terminals():
        taxid = tip.guids['taxon']

        # Focal tip is annotated with an NCBI taxon ID in the provided lists
        if taxid in taxids:
            tips.append(tip)
            logging.debug(f'Found tip {tip.name} with taxid {taxid}')
    logging.info(f'Found {len(tips)} tips for {len(taxids)} in the tree')

    # Iterate over the collected tips to find their lineages to build a set
    # of distinct higher taxa with the specified rank
    taxa = set()
    for tip in tips:
        for node in tree.root.get_path(tip):
            logging.debug(f'Traversing {node} from lineage {tip}')
            if node.taxonomic_rank == str(config.get('level')).lower():
                taxa.add(node)
                logging.info(f"Found ancestor '{node}' for '{tip}'")
    logging.info(f'Collected {len(taxa)} higher taxa')
    return list(taxa)


